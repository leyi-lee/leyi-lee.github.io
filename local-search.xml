<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>channel 源码解析</title>
    <link href="/2023/08/18/channel/"/>
    <url>/2023/08/18/channel/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-channel"><a href="#什么是-channel" class="headerlink" title="什么是 channel"></a>什么是 channel</h3><ul><li>channel 是 Go 语言中的<strong>并发原语</strong> , 通过 <strong>channel</strong> 可以在 <strong>goroutine</strong> 之间传递数据。是一种特殊的数据结构，它可以作为一个管道来接受和发送数据。</li><li>并发模型：CSP 通信顺序模型</li></ul><h3 id="channel-源码解析"><a href="#channel-源码解析" class="headerlink" title="channel 源码解析"></a>channel 源码解析</h3><blockquote><p>版本为 1.19.3  </p></blockquote><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">maxAlign  = <span class="hljs-number">8</span> <span class="hljs-comment">// 内存对齐</span><br><br><span class="hljs-comment">// unsafe.Sizeof(hchan&#123;&#125;) 获取 hchan 数据结构的字节大小</span><br><span class="hljs-comment">// uintptr(-int(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign-1)) 进行对齐操作</span><br><span class="hljs-comment">// 假设 hchan 大小为 21，按 8 对齐， 21 + (-21 &amp; 7) = 24 </span><br>hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="hljs-type">uintptr</span>(-<span class="hljs-type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="hljs-number">-1</span>))<br>debugChan = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h4 id="hchan-结构"><a href="#hchan-结构" class="headerlink" title="hchan 结构"></a>hchan 结构</h4><ul><li>buff 主要字段<ul><li>qccount buff 中的数量</li><li>dataqsize 循环数组大小</li><li>sendx、recvx</li></ul></li><li>队列<ul><li>recvq、 sendq</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>qcount   <span class="hljs-type">uint</span> <span class="hljs-comment">// 现有 buff 中的数量</span><br>dataqsiz <span class="hljs-type">uint</span> <span class="hljs-comment">// 循环数组的大小</span><br>buf      unsafe.Pointer <span class="hljs-comment">// 指向循环数组的指针</span><br>elemsize <span class="hljs-type">uint16</span> <span class="hljs-comment">// channel 元素大小</span><br>closed   <span class="hljs-type">uint32</span> <span class="hljs-comment">// channel 是否关闭 0 是没有关闭</span><br>elemtype *_type <span class="hljs-comment">// 元素类型</span><br>sendx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// 待发送的循环数组下标</span><br>recvx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// 待接受的循环数组下标</span><br>recvq    waitq  <span class="hljs-comment">// 等待接受的队列</span><br>sendq    waitq  <span class="hljs-comment">// 等待发送的队列</span><br>&#125;<br><br><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;<br>first *sudog  <span class="hljs-comment">// goroutine</span><br>last  *sudog<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="channel-创建"><a href="#channel-创建" class="headerlink" title="channel 创建"></a>channel 创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-type">int</span>)</span></span> *hchan &#123;<br>elem := t.elem<br><br>    <span class="hljs-comment">// 编译器会检查元素类型太大做限制</span><br><span class="hljs-keyword">if</span> elem.size &gt;= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span> &#123;<br>throw(<span class="hljs-string">&quot;makechan: invalid channel element type&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 校验是否内存对齐</span><br><span class="hljs-keyword">if</span> hchanSize%maxAlign != <span class="hljs-number">0</span> || elem.align &gt; maxAlign &#123;<br>throw(<span class="hljs-string">&quot;makechan: bad alignment&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 元素大小 * 个数 是否溢出</span><br>mem, overflow := math.MulUintptr(elem.size, <span class="hljs-type">uintptr</span>(size))<br><span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;makechan: size out of range&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">var</span> c *hchan<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> mem == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// size 为 0时，或者元素大小为 0，只需要分配 hchan 本身大小即可</span><br>c = (*hchan)(mallocgc(hchanSize, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>c.buf = c.raceaddr()<br><span class="hljs-keyword">case</span> elem.ptrdata == <span class="hljs-number">0</span>:<br><span class="hljs-comment">// 元素中不包含指针</span><br><span class="hljs-comment">// hchan 和元素大小直接分配，连续内存空间</span><br>c = (*hchan)(mallocgc(hchanSize+mem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>c.buf = add(unsafe.Pointer(c), hchanSize)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 元素包含指针</span><br><span class="hljs-comment">// 分别为 hchan 和 buf 分配内存</span><br>c = <span class="hljs-built_in">new</span>(hchan)<br>c.buf = mallocgc(mem, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">// 设置元素大小</span><br>c.elemsize = <span class="hljs-type">uint16</span>(elem.size)<br><span class="hljs-comment">// 元素类型</span><br>c.elemtype = elem<br><span class="hljs-comment">// 循环队列的大小</span><br>c.dataqsiz = <span class="hljs-type">uint</span>(size)<br><br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>创建大小 &#x3D; hchan 结构 + 元素类型 * size</li><li>计算 buff 大小，元素类型 * size</li><li>如果 buff 为 0，则创建 hchan 大小</li><li>如果元素类型不为指针，则 hchan 和 buff 分配连续内存</li><li>如果元素为指针，则各为 hchan 和 buff 创建</li></ul><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><blockquote><p>阻塞、非阻塞<br>chansend1 阻塞， selectnbsend 非阻塞</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 阻塞调用 c &lt;- x</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>chansend(c, elem, <span class="hljs-literal">true</span>, getcallerpc())<br>&#125;<br><br><span class="hljs-comment">// 非阻塞调用</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">//select &#123;</span><br><span class="hljs-comment">//case c &lt;- v:</span><br><span class="hljs-comment">//... foo</span><br><span class="hljs-comment">//default:</span><br><span class="hljs-comment">//... bar</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// as</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//if selectnbsend(c, v) &#123;</span><br><span class="hljs-comment">//... foo</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//... bar</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectnbsend</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span> chansend(c, elem, <span class="hljs-literal">false</span>, getcallerpc())<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><br><span class="hljs-comment">// chan == nil 非阻塞直接返回 false 、阻塞模式会挂起 goroutine 永久阻塞</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> !block &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chansend: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend))<br>&#125;<br><br>    <span class="hljs-comment">// 非阻塞模式下，未关闭且循环数组已满，直接返回</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; full(c) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 记录运行时间</span><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br><span class="hljs-comment">// 加锁</span><br>lock(&amp;c.lock)<br><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 如果已关闭，解锁并抛出异常</span><br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 判断等待接受的队列有goroutine，取出来，直接复制数据到等待的 goroutine 上，（类似零拷贝，不走缓冲区）</span><br>send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 判断元素数量小于循环数组大小（buff 还有容量）</span><br><span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br><span class="hljs-comment">// 计算要存放的循环数组的位置</span><br>qp := chanbuf(c, c.sendx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.sendx, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// 要发送的元素拷贝到缓冲区</span><br>typedmemmove(c.elemtype, qp, ep)<br><br><span class="hljs-comment">// 下标+1</span><br>c.sendx++<br><span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123; <span class="hljs-comment">// 如果到尾部，从头开始</span><br>c.sendx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount++ <span class="hljs-comment">// 元素++</span><br>unlock(&amp;c.lock) <span class="hljs-comment">// 解锁</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// 如果 buff 没有位置了，并且是非阻塞，直接返回失败</span><br><span class="hljs-keyword">if</span> !block &#123;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// buff 没有位置，且阻塞情况</span><br>gp := getg() <span class="hljs-comment">// 获取当前发送的 goroutine</span><br>mysg := acquireSudog() <span class="hljs-comment">// 获取 sudog 结构体</span><br>mysg.releasetime = <span class="hljs-number">0</span> <br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 绑定各种参数</span><br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.waiting = mysg<br>gp.param = <span class="hljs-literal">nil</span><br>c.sendq.enqueue(mysg) <span class="hljs-comment">// 插入到队列</span><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 挂起当前 goroutine，进入休眠等待接受</span><br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 确保发送的值一直在，直到有接受方复制出来，避免被 GC</span><br>KeepAlive(ep)<br><br><span class="hljs-comment">// 被唤醒 </span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br>closed := !mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-comment">// 取消 chan 与 sudog 的关系</span><br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg) <span class="hljs-comment">// 释放 mysg</span><br><span class="hljs-keyword">if</span> closed &#123;<br><span class="hljs-keyword">if</span> c.closed == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;chansend: spurious wakeup&quot;</span>)<br>&#125;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span></span>, skip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br><span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;<br>racesync(c, sg)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>racenotify(c, c.recvx, sg)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// sudog 上的元素不是 nil</span><br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 直接复制</span><br>sendDirect(c.elemtype, sg, ep)<br>sg.elem = <span class="hljs-literal">nil</span><br><span class="hljs-comment">// 复制完，清楚当前 sudog 上的参数</span><br>&#125;<br><br><span class="hljs-comment">// 获取等待接受的 goroutine</span><br>gp := sg.g<br>unlockf() <span class="hljs-comment">// 解锁</span><br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br><span class="hljs-comment">// 唤醒接受的 goroutine</span><br>goready(gp, skip+<span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>小结</p><ul><li>分为阻塞和非阻塞</li><li>普通 x &lt;- c 为阻塞， select 为非阻塞</li><li>chan &#x3D;&#x3D; nil，非阻塞返回 false，阻塞模式 goroutine 挂起<strong>永久阻塞</strong></li><li>非阻塞 并且 chan 未关闭，并且 buff 没空间 则返回 false</li><li>closed &#x3D;&#x3D; 1，panic error</li><li>有等待的 goroutine 则将元素直接复制到等待 g 并唤醒 goready</li><li>如果 buff 有位置，则计算要存放的位置，放入</li><li>如果 buff 没有位置，获取 sudog，并且绑定 goroutine ，且放入队列，并且挂起当前 goroutine</li><li>唤醒后，释放 sudog</li></ul><h4 id="接受"><a href="#接受" class="headerlink" title="接受"></a>接受</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 阻塞调用</span><br><span class="hljs-comment">// x := &lt;- c</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>chanrecv(c, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br><span class="hljs-comment">// 非阻塞调用</span><br><span class="hljs-comment">//select &#123;</span><br><span class="hljs-comment">//case v, ok = &lt;-c:</span><br><span class="hljs-comment">//... foo</span><br><span class="hljs-comment">//default:</span><br><span class="hljs-comment">//... bar</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// as</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//if selected, ok = selectnbrecv(&amp;v, c); selected &#123;</span><br><span class="hljs-comment">//... foo</span><br><span class="hljs-comment">//&#125; else &#123;</span><br><span class="hljs-comment">//... bar</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectnbrecv</span><span class="hljs-params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span> chanrecv(c, elem, <span class="hljs-literal">false</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">if</span> debugChan &#123;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;chanrecv: chan=&quot;</span>, c, <span class="hljs-string">&quot;\n&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// chan == nil</span><br><span class="hljs-keyword">if</span> !block &#123; <span class="hljs-comment">// 非阻塞 直接返回,selected nil, receive false</span><br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 阻塞模式，挂起当前 goroutine 永久阻塞</span><br>gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 快速检测 非阻塞模式并且接受数据会阻塞 </span><br><span class="hljs-comment">// empty(c) 为 true 情况</span><br><span class="hljs-comment">// 1.元素大小为 0, 待发送的 sendq 也没有</span><br><span class="hljs-comment">//  2.buff 大小为 0</span><br><span class="hljs-keyword">if</span> !block &amp;&amp; empty(c) &#123;<br><span class="hljs-keyword">if</span> atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> empty(c) &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> t0 <span class="hljs-type">int64</span><br><span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;<br>t0 = cputicks()<br>&#125;<br><br>lock(&amp;c.lock)<br><br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 已关闭 并且 元素大小为 0,直接返回</span><br><span class="hljs-keyword">if</span> c.qcount == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquire(c.raceaddr())<br>&#125;<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, ep)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 未关闭，且发送队列有数据, 拷贝数据到当前 goroutine</span><br><span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 从 buff 获取元素</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// 从发送方拷贝数据到接受方</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><br><span class="hljs-comment">// 拷贝完清理</span><br>typedmemclr(c.elemtype, qp)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.qcount--<br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">if</span> !block &#123; <span class="hljs-comment">// 非阻塞且 没有元素直接返回</span><br>unlock(&amp;c.lock)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 没有发送方也没有元素，获取 sudog 并且绑定参数，进行阻塞</span><br>gp := getg()<br>mysg := acquireSudog()<br>mysg.releasetime = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;<br>mysg.releasetime = <span class="hljs-number">-1</span><br>&#125;<br>mysg.elem = ep<br>mysg.waitlink = <span class="hljs-literal">nil</span><br>gp.waiting = mysg<br>mysg.g = gp<br>mysg.isSelect = <span class="hljs-literal">false</span><br>mysg.c = c<br>gp.param = <span class="hljs-literal">nil</span><br>c.recvq.enqueue(mysg) <span class="hljs-comment">// 加入到队列</span><br><br>atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// 挂起当前 goroutine</span><br>gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 被唤醒后的操作，释放 sudog</span><br><span class="hljs-keyword">if</span> mysg != gp.waiting &#123;<br>throw(<span class="hljs-string">&quot;G waiting list is corrupted&quot;</span>)<br>&#125;<br>gp.waiting = <span class="hljs-literal">nil</span><br>gp.activeStackChans = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;<br>blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)<br>&#125;<br>success := mysg.success<br>gp.param = <span class="hljs-literal">nil</span><br>mysg.c = <span class="hljs-literal">nil</span><br>releaseSudog(mysg)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, success<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span></span>, skip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 无缓冲</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racesync(c, sg)<br>&#125;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 直接拷贝</span><br>recvDirect(c.elemtype, sg, ep)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 有 sendq 说明buff已满</span><br><span class="hljs-comment">// 获取循环队列的头部元素，并把 sendq 要发送的元素放入循环队列 buff 中</span><br><span class="hljs-comment">// 队列已满，发送和接受是同一位置</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> raceenabled &#123;<br>racenotify(c, c.recvx, <span class="hljs-literal">nil</span>)<br>racenotify(c, c.recvx, sg)<br>&#125;<br><span class="hljs-comment">// 从循环队列拷贝数据到接受者</span><br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><span class="hljs-comment">// 拷贝数据从发送者到队列</span><br>typedmemmove(c.elemtype, qp, sg.elem)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.sendx = c.recvx <span class="hljs-comment">// 队列已满, 开始 recvx == sendx，recvx 移走，发送队列的元素添加进来，移动 sendx 与 recvx 相等</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br>gp := sg.g<br>unlockf()<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br><span class="hljs-comment">// 唤醒 sendq</span><br>goready(gp, skip+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>channel &#x3D;&#x3D; nil， 阻塞模式下永久挂起，非阻塞模式：直接返回 false</li><li>非阻塞模式下，快速判断</li><li>closed &#x3D;&#x3D; 1，并且 buff 中无数据，直接返回</li><li>有等待的 sendq, qcount &#x3D;&#x3D; 0，buff 中无元素直接复制 sendq elem 到 recvq,</li><li>buff 中有数据，获取 recvx 的元素到 recvq，并且把 sendq 的元素复制到 buff 中，唤醒 sendq</li><li>无等待的 sendq，从 buff 中取数据到 recvq 返回</li><li>buff 中无数据，创建 sudog 放入 recvq 队列中，等待被唤醒</li></ul><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;<br><span class="hljs-comment">// 关闭一个未初始化的 异常</span><br><span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of nil channel&quot;</span>))<br>&#125;<br><br>lock(&amp;c.lock)<br><span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 关闭已关闭的异常</span><br>unlock(&amp;c.lock)<br><span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of closed channel&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>callerpc := getcallerpc()<br>racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))<br>racerelease(c.raceaddr())<br>&#125;<br><br><span class="hljs-comment">// 关闭</span><br>c.closed = <span class="hljs-number">1</span><br><br><span class="hljs-comment">// goroutine list</span><br><span class="hljs-keyword">var</span> glist gList<br><br><span class="hljs-comment">// 释放所有接受队列</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.recvq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br>typedmemclr(c.elemtype, sg.elem)<br>sg.elem = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br><span class="hljs-comment">// 放入 list</span><br>glist.push(gp)<br>&#125;<br><br><span class="hljs-comment">// 释放所有发送队列</span><br><span class="hljs-keyword">for</span> &#123;<br>sg := c.sendq.dequeue()<br><span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;<br>sg.releasetime = cputicks()<br>&#125;<br>gp := sg.g<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> raceenabled &#123;<br>raceacquireg(gp, c.raceaddr())<br>&#125;<br><span class="hljs-comment">// 放入 list</span><br>glist.push(gp)<br>&#125;<br>unlock(&amp;c.lock)<br><br><span class="hljs-comment">// 唤醒 </span><br><span class="hljs-keyword">for</span> !glist.empty() &#123;<br>gp := glist.pop()<br>gp.schedlink = <span class="hljs-number">0</span><br>goready(gp, <span class="hljs-number">3</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>如何避免关闭已经关闭的  &#x3D;&#x3D;sync.Once&#x3D;&#x3D;</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><table><thead><tr><th align="center">操作</th><th align="center">nil</th><th align="center">已关闭的 channel</th><th align="center">有缓冲 channel</th><th align="center">无缓冲 channel</th></tr></thead><tbody><tr><td align="center">关闭</td><td align="center">panic</td><td align="center">panic</td><td align="center">可以关闭,读完 buff,返回 channel类型默认值</td><td align="center">可以关闭，读到 channel 类型默认值</td></tr><tr><td align="center">发送</td><td align="center">阻塞</td><td align="center">panic</td><td align="center">放入 buff，正常返回</td><td align="center">阻塞，挂起</td></tr><tr><td align="center">接受</td><td align="center">阻塞</td><td align="center">不阻塞，读到默认值</td><td align="center">读buff 数据，正常返回</td><td align="center">阻塞挂起</td></tr></tbody></table><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>使用 select 监听多个处理</li><li>只在写入端关闭 chan，不在读取关闭</li><li>goroutine 通信</li><li>异步操作</li><li>任务分发</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mutex</title>
    <link href="/2023/07/05/mutex/"/>
    <url>/2023/07/05/mutex/</url>
    
    <content type="html"><![CDATA[<h2 id="Go-Mutex"><a href="#Go-Mutex" class="headerlink" title="Go Mutex"></a>Go Mutex</h2><p>Mutex 为互斥锁</p><p>分两种模式: <code>正常模式</code>, <code>饥饿模式</code><br><strong>———–</strong></p><p>正常模式: 队列中的goroutine按先入先出排队获取锁，被唤醒的goroutine不会直接持有锁，而是需要和正在运行的goroutine竞争，但其实这个是不公平的，新请求的goroutine正在cpu上运行有优势，如果唤醒的goroutine未获取到锁则直接插入到队列头部，如果等待中的goroutine超过1ms未获取到锁，则直接放到队列头部</p><p>饥饿模式: 新来的groutine不与队列中的竞争，直接放入队尾，如果唤醒的goroutine获取了锁，它是队列最后一个或者等待时长小于1ms则切换回正常模式</p><h3 id="Mutex-结构体"><a href="#Mutex-结构体" class="headerlink" title="Mutex 结构体"></a>Mutex 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Mutex <span class="hljs-keyword">struct</span> &#123;<br>state <span class="hljs-type">int32</span><br>sema  <span class="hljs-type">uint32</span><br>&#125;<br><br><span class="hljs-comment">// google 翻译</span><br><span class="hljs-comment">// 互斥公平性。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 互斥体可以有两种操作模式：正常模式和饥饿模式。</span><br><span class="hljs-comment">// 在正常模式下，等待者按照 FIFO 顺序排队，但是唤醒等待者不拥有互斥体并与新到达的 goroutine 竞争所有权。 新到来的 goroutine 有一个优势——它们是已经在 CPU 上运行并且可能有很多，所以被唤醒服务员很有可能会输。 在这种情况下，它会排在前面等待队列。 如果服务员未能获取互斥量超过 1ms，它将互斥体切换到饥饿模式。</span><br><span class="hljs-comment">// 在饥饿模式下，互斥量的所有权直接从给队列前面的服务员解锁 goroutine。 新到达的 goroutine 不会尝试获取互斥体，即使它出现解锁，不要尝试旋转。 相反，他们自己排队等待队列的尾部。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 如果服务员收到互斥体的所有权并看到</span><br><span class="hljs-comment">// (1) 它是队列中的最后一个服务员，或者 (2) 它等待的时间少于 1 毫秒，</span><br><span class="hljs-comment">// 它将互斥体切换回正常操作模式。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 正常模式具有相当好的性能，因为 goroutine 可以获得</span><br><span class="hljs-comment">// 即使有阻塞的服务员，也可以连续多次使用互斥体。</span><br><span class="hljs-comment">// 饥饿模式对于防止尾部延迟的病态情况很重要。</span><br><br><span class="hljs-keyword">const</span> (<br>mutexLocked = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// 加锁 001 =&gt; 1 &lt;&lt; 0 = 1</span><br>    mutexWoken <span class="hljs-comment">// 是否唤醒 010 =&gt; 1 &lt;&lt; 1 = 2</span><br>mutexStarving <span class="hljs-comment">// 是否饥饿模式 100 =&gt; 1 &lt;&lt; 2 = 4</span><br>mutexWaiterShift = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 3  等待者+1   例如 new + 1 &lt;&lt; mutexWaiterShift = new + 1 &lt;&lt; 3 = new + 8</span><br><br>starvationThresholdNs = <span class="hljs-number">1e6</span> <span class="hljs-comment">// 等待时长</span><br>)<br><br></code></pre></td></tr></table></figure><h3 id="Mutex-方法"><a href="#Mutex-方法" class="headerlink" title="Mutex 方法"></a>Mutex 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> Locker <span class="hljs-keyword">interface</span> &#123;<br>Lock()<br>Unlock()<br>&#125;<br><br><br><span class="hljs-comment">// 锁方法，如果锁已被使用，则调用goroutine阻塞，一直到锁可用</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock() &#123;<br><span class="hljs-comment">// Fast path: 直接获取到锁 </span><br><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="hljs-number">0</span>, mutexLocked) &#123;<br><span class="hljs-keyword">if</span> race.Enabled &#123;<br>race.Acquire(unsafe.Pointer(m))<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// Slow path (outlined so that the fast path can be inlined)</span><br>    <span class="hljs-comment">// 慢路径，内联方法(没太懂)</span><br>m.lockSlow()<br>&#125;<br><br><span class="hljs-comment">// TryLock tries to lock m and reports whether it succeeded.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Note that while correct uses of TryLock do exist, they are rare,</span><br><span class="hljs-comment">// and use of TryLock is often a sign of a deeper problem</span><br><span class="hljs-comment">// in a particular use of mutexes.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> TryLock() <span class="hljs-type">bool</span> &#123;<br>old := m.state<br><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// There may be a goroutine waiting for the mutex, but we are</span><br><span class="hljs-comment">// running now and can try to grab the mutex before that</span><br><span class="hljs-comment">// goroutine wakes up.</span><br><span class="hljs-keyword">if</span> !atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexLocked) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">if</span> race.Enabled &#123;<br>race.Acquire(unsafe.Pointer(m))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> lockSlow() &#123;<br><span class="hljs-keyword">var</span> waitStartTime <span class="hljs-type">int64</span><br>starving := <span class="hljs-literal">false</span><br>awoke := <span class="hljs-literal">false</span><br>iter := <span class="hljs-number">0</span><br>old := m.state<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span><br><span class="hljs-comment">// so we won&#x27;t be able to acquire the mutex anyway.</span><br><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;<br><span class="hljs-comment">// Active spinning makes sense.</span><br><span class="hljs-comment">// Try to set mutexWoken flag to inform Unlock</span><br><span class="hljs-comment">// to not wake other blocked goroutines.</span><br><span class="hljs-keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="hljs-number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="hljs-number">0</span> &amp;&amp;<br>atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;<br>awoke = <span class="hljs-literal">true</span><br>&#125;<br>runtime_doSpin()<br>iter++<br>old = m.state<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-built_in">new</span> := old<br><span class="hljs-comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span><br><span class="hljs-keyword">if</span> old&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">new</span> |= mutexLocked<br>&#125;<br><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">new</span> += <span class="hljs-number">1</span> &lt;&lt; mutexWaiterShift<br>&#125;<br><span class="hljs-comment">// The current goroutine switches mutex to starvation mode.</span><br><span class="hljs-comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span><br><span class="hljs-comment">// Unlock expects that starving mutex has waiters, which will not</span><br><span class="hljs-comment">// be true in this case.</span><br><span class="hljs-keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">new</span> |= mutexStarving<br>&#125;<br><span class="hljs-keyword">if</span> awoke &#123;<br><span class="hljs-comment">// The goroutine has been woken from sleep,</span><br><span class="hljs-comment">// so we need to reset the flag in either case.</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexWoken == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>&#125;<br><span class="hljs-built_in">new</span> &amp;^= mutexWoken<br>&#125;<br><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span> <span class="hljs-comment">// locked the mutex with CAS</span><br>&#125;<br><span class="hljs-comment">// If we were already waiting before, queue at the front of the queue.</span><br>queueLifo := waitStartTime != <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> waitStartTime == <span class="hljs-number">0</span> &#123;<br>waitStartTime = runtime_nanotime()<br>&#125;<br>runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="hljs-number">1</span>)<br>starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br>old = m.state<br><span class="hljs-keyword">if</span> old&amp;mutexStarving != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// If this goroutine was woken and mutex is in starvation mode,</span><br><span class="hljs-comment">// ownership was handed off to us but mutex is in somewhat</span><br><span class="hljs-comment">// inconsistent state: mutexLocked is not set and we are still</span><br><span class="hljs-comment">// accounted as waiter. Fix that.</span><br><span class="hljs-keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="hljs-number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> &#123;<br>throw(<span class="hljs-string">&quot;sync: inconsistent mutex state&quot;</span>)<br>&#125;<br>delta := <span class="hljs-type">int32</span>(mutexLocked - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift)<br><span class="hljs-keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">// Exit starvation mode.</span><br><span class="hljs-comment">// Critical to do it here and consider wait time.</span><br><span class="hljs-comment">// Starvation mode is so inefficient, that two goroutines</span><br><span class="hljs-comment">// can go lock-step infinitely once they switch mutex</span><br><span class="hljs-comment">// to starvation mode.</span><br>delta -= mutexStarving<br>&#125;<br>atomic.AddInt32(&amp;m.state, delta)<br><span class="hljs-keyword">break</span><br>&#125;<br>awoke = <span class="hljs-literal">true</span><br>iter = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>old = m.state<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> race.Enabled &#123;<br>race.Acquire(unsafe.Pointer(m))<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Unlock unlocks m.</span><br><span class="hljs-comment">// It is a run-time error if m is not locked on entry to Unlock.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// A locked Mutex is not associated with a particular goroutine.</span><br><span class="hljs-comment">// It is allowed for one goroutine to lock a Mutex and then</span><br><span class="hljs-comment">// arrange for another goroutine to unlock it.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Unlock() &#123;<br><span class="hljs-keyword">if</span> race.Enabled &#123;<br>_ = m.state<br>race.Release(unsafe.Pointer(m))<br>&#125;<br><br><span class="hljs-comment">// Fast path: drop lock bit.</span><br><span class="hljs-built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span> != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// Outlined slow path to allow inlining the fast path.</span><br><span class="hljs-comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span><br>m.unlockSlow(<span class="hljs-built_in">new</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> unlockSlow(<span class="hljs-built_in">new</span> <span class="hljs-type">int32</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="hljs-number">0</span> &#123;<br>fatal(<span class="hljs-string">&quot;sync: unlock of unlocked mutex&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">new</span>&amp;mutexStarving == <span class="hljs-number">0</span> &#123;<br>old := <span class="hljs-built_in">new</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// If there are no waiters or a goroutine has already</span><br><span class="hljs-comment">// been woken or grabbed the lock, no need to wake anyone.</span><br><span class="hljs-comment">// In starvation mode ownership is directly handed off from unlocking</span><br><span class="hljs-comment">// goroutine to the next waiter. We are not part of this chain,</span><br><span class="hljs-comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span><br><span class="hljs-comment">// So get off the way.</span><br><span class="hljs-keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="hljs-number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// Grab the right to wake someone.</span><br><span class="hljs-built_in">new</span> = (old - <span class="hljs-number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken<br><span class="hljs-keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="hljs-built_in">new</span>) &#123;<br>runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>old = m.state<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Starving mode: handoff mutex ownership to the next waiter, and yield</span><br><span class="hljs-comment">// our time slice so that the next waiter can start to run immediately.</span><br><span class="hljs-comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span><br><span class="hljs-comment">// But mutex is still considered locked if mutexStarving is set,</span><br><span class="hljs-comment">// so new coming goroutines won&#x27;t acquire it.</span><br>runtime_Semrelease(&amp;m.sema, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>https 交互详细过程</title>
    <link href="/2023/06/27/https/"/>
    <url>/2023/06/27/https/</url>
    
    <content type="html"><![CDATA[<h3 id="https-简述"><a href="#https-简述" class="headerlink" title="https 简述"></a>https 简述</h3><ul><li>http + SSL&#x2F;TLS</li><li>SSL&#x2F;TLS 处于应用层之下，TCP&#x2F;IP 层之上</li></ul><h3 id="https-请求过程"><a href="#https-请求过程" class="headerlink" title="https 请求过程"></a>https 请求过程</h3><pre><code class="hljs">1.  TCP/IP 三次握手之后2.  Client 发送 Client Hello    1.  随机数 random\_C 后续生产会话密钥    2.  支持的加密套件列表 ECDH+RSA+AES+SHA256 等    3.  TLS 最高协议 TLS1.0    4.  压缩方法列表等3.  Server 发送 Server Hello    1.  随机数 random\_S 后续生成会话密钥    2.  确认加密套件 ECDH+RSA+AES+SHA256        1.  ECDH 是协商密钥算法        2.  RSA 签名使用        3.  AES 对称加密算法        4.  SHA256 摘要算法    3.  确认压缩方法    4.  Server 发送证书 （收到 Client Ack 确认后）    5.  Server 发送 server Key exchange （如果密钥协商算法是 ECDH 有这一步）        1.  生成随机数作为椭圆曲线的私钥        2.  会把椭圆 G 点和根据服务器私钥生成的公钥发过来        3.  再用 RSA 签名，防止篡改    6.  Server hello done4.  Client 验证证书    1.  证书包含        1.  证书内容-&gt; 到期时间、域名、中间证书颁发地址        2.  通过摘要算法对证书生成hash        3.  使用证书私钥对 hash 进行数字签名    2.  验证        1.  通过根证书公钥对中间证书验签        2.  中间证书公钥对证书验签        3.  检查证书内容5.  Client key Exchange 发送给 Server    1.  生成随机数作为私钥    2.  根据服务端给的消息，生成公钥</code></pre><p><img src="/img/https.png" alt="https 交互流程图"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
